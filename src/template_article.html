<!-- 
  svg_bg -> main.js creates ands animate an svg
-->
<script type="text/javascript"> 
</script>
<div id="scroll_progress_bar"></div>
<div id="svg_bg"></div>
<style>
#svg_bg{
  position: fixed;
  z-index: -99; 
}
</style>
<script>
  window.rir = (min, max) => Math.floor(Math.random() * (Math.floor(max) - Math.ceil(min) + 1)) + Math.ceil(min);
</script>
<script type="text/javascript"> 
const createSvgBg = async () => { 
    // Create cubes
    const svg1 = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg1.setAttribute ("width", "100vw" ); svg1.setAttribute ("height", "100vh" ); 
    Array(rir(15,25)).fill().map( () => {  
        const x = rir(0,200)+'vh'; const y = rir(0,100)+'vh';
        const size = rir(40,80)
        var rect = document.createElementNS("http://www.w3.org/2000/svg", 'rect');
        rect.setAttribute('x', x); rect.setAttribute('y', y);
        rect.setAttribute('height', size); rect.setAttribute('width', size);
        rect.setAttribute('fill', ['red','green','orange', 'blue'][rir(0,3)]);
        svg1.appendChild(rect);
    }) 
    // Animate Cubes
    r = document.getElementById('svg_bg'); r.innerHTML = ''; r.appendChild(svg1) 
    svg1.querySelectorAll('rect').forEach(rect => { 
        let x = parseInt(rect.getAttribute('x').slice(0, -2))
        let y = parseInt(rect.getAttribute('y').slice(0, -2)); 
        rect.animate([ 
            {x: x-rir(0,10)+'vh', y: y-rir(100,125)+'vh'},
            {x: x+rir(0,10)+'vh', y: y+rir(100,125)+'vh'},
        ], { 
            duration: 20000,
            iterations: Infinity,
        }); 
    }); 
}; createSvgBg(); setInterval(createSvgBg,20000) 
</script>

<!-- 
  gradient_bg
-->
<div id="gradient_bg"></div>
<style>
#gradient_bg{
  position: fixed;
  height: 100vh;
  width: 100vw;
	background: linear-gradient(180deg, var(--bg1), var(--bg2));
	background-size: 100% 200%;
	animation: gradient 60s ease infinite; 
  z-index: -99;
}
@keyframes gradient {
	0% {		background-position: 0% 0%;	} 
	50% {	  background-position: 100% 100%;	} 
	100% {	background-position: 0% 0%;	}  
}
</style> 

<style type="text/css">
  body:has(#sitemap:focus-within) { 
    overscroll-behavior-y: contain; /* Prevent drag-refresh */
  } 
  #sitemap{
    position: fixed;
    width: fit-content;
    top: 0;
    left: 0;  
    z-index: 999;
    overflow: hidden;   
    border-radius: .7rem;
    padding: 1rem;
    padding-top: 0px;

    backdrop-filter: blur(2px) saturate(100%);
    -webkit-backdrop-filter: blur(2px) saturate(100%);
    background-color: var(--bg5);
    border-radius: 12px; 
    box-shadow: 5px 0 20px var(--bg4), -5px 0 20px var(--hint-of-light), inset 0px 0 10px var(--hint-of-light);
  }
  @keyframes pulse { 50% { box-shadow: 5px 0 20px var(--hint-of-light), -5px 0 20px var(--bg4), inset 0px 0 10px var(--bg4); } }

  /* hide checkbox, but still expose it to screen readers.*/
  input { position: absolute;  width: 1px; clip: rect(0 0 0 0); overflow: hidden; white-space: nowrap; }

  /* Use Labels to trigger CSS Effects on checkbox checked */
  #toggle-sitemap{ visibility: hidden; }
  #toggle-sitemap:not(:checked) ~ #sitemap { animation: collapse 1s forwards, pulse 6s linear infinite; }
  #toggle-sitemap:checked ~ #sitemap { animation: expand 1s forwards, pulse 6s linear infinite; }
  @keyframes collapse { from { max-height:75vh} to { max-height:3em; } }
  @keyframes expand { to { max-height:75vh } from { max-height:3em; } }

  /* Use Labels to trigger CSS Effects on checkbox checked */
  #sitemap > label {line-height: 3em; width: -webkit-fill-available; display: inline-block; cursor: grab; }
  #sitemap > label > span:nth-child(1){ position:absolute; } 
  #toggle-sitemap:not(:checked) ~ #sitemap > label > span:nth-child(1) { animation: dismiss 1s forwards;  }
  #toggle-sitemap:not(:checked) ~ #sitemap > *:nth-child() { animation: dismiss 1s forwards;  } 
  #toggle-sitemap:checked ~ #sitemap > label > span:nth-child(1) { animation: reveal 500ms forwards;  }
  #toggle-sitemap:not(:checked) ~ #sitemap > *:nth-child() { animation: reveal 1s forwards;  }
  @keyframes reveal {  from {transform:rotate(0deg)} to {transform: rotate(90deg); } }
  @keyframes dismiss { from {transform:rotate(90deg)} to {transform: rotate(0deg); } }
  </style> 
  
  <!-- this checkbox holds state of whether modal is visible or not -->
  <input type="checkbox" id="toggle-sitemap">
  <div id="sitemap"> 
    <label for="toggle-sitemap"><span>Hide</span> <span>Show </span>Sitemap</label>
    <caption>Click or Drag</caption>
  </div>

  <script>
    const dragTarget = document.querySelector("#sitemap"); 
    let inDrag = false;
    function downFN(e) {
        inDrag = true;
        objInitLeft = dragTarget.offsetLeft; objInitTop = dragTarget.offsetTop;
        dragStartX = e.pageX || e.targetTouches[0].clientX; 
        dragStartY = e.pageY || e.targetTouches[0].clientY; 
    }
    function moveFN(e) {
        if (!inDrag) {return;} 
        e.preventDefault();
        dragToX = e.pageX || e.targetTouches[0].clientX; 
        dragToY = e.pageY || e.targetTouches[0].clientY; 
        dragTarget.style.left = (objInitLeft + dragToX-dragStartX) + "px";
        dragTarget.style.top = (objInitTop + dragToY-dragStartY) + "px";
      } 
    (function() {
      // start = mousepos & objInit = topleft of obj
      var dragStartX, dragStartY, objInitLeft, objInitTop = 0;
      dragTarget.addEventListener("mousedown", downFN );
      document.addEventListener("mousemove", moveFN,{ passive:false });
      document.addEventListener("mouseup", function(e) {inDrag = false}); 
      dragTarget.addEventListener("touchstart", downFN );
      dragTarget.addEventListener("touchmove", moveFN,{ passive:false });
      dragTarget.addEventListener("touchend", function(e) {inDrag = false;});
    }())
  </script>

<style>
  #header{
    /* center and size to header_nav*/
    width: fit-content;
    margin: auto;
  }
  #header_nav{
    padding: 12px;
    text-align: center;
    z-index: 9;
  }
  #header_bg_wrapper{
    position: absolute;
    top:0px;
    width:100%;
    height:100%;   
    filter: drop-shadow(20px 20px 60px #bebebe) drop-shadow(-20px -20px 60px #ffffff); /* https://neumorphism.io/ */
  }
  #header_bg{  
    border-radius: 50px;
    width:100%;
    height:100%;  
    background-color: var(--bg3);
    clip-path: polygon(33% 43%, 0 43%, 0 0, 100% 0, 100% 43%, 66% 43%, 66% 66%, 100% 66%, 100% 100%, 0 100%, 0 66%, 33% 66%);
    animation:spin 2s linear alternate infinite;
    transition-duration: 2s;
  } 
  #header:hover > #header_bg_wrapper > #header_bg{
    clip-path: polygon(0% 15%, 15% 15%, 15% 0%, 85% 0%, 85% 15%, 100% 15%, 100% 85%, 85% 85%, 85% 100%, 15% 100%, 15% 85%, 0% 85%);
  } 
  @keyframes spin{ from{transform:rotate(-2deg)} to{transform:rotate(2deg)} }
  </style>

<!-- 
  CONTENT
-->
<div style="height:30px"></div>
<div id="header">
  <div id="header_nav" >
    <h1><a  style="cursor: pointer;" href="/">CVMiniGames</a> | <a href="./" id="title"></a></h1>
    <p><a style="cursor: pointer;" target=blank href="https://www.cryptovoxels.com/play?coords=N@1447E,1128S">PLAY NOW</a></p>
    <p id="summary"></p>
  </div>
  <span id="header_bg_wrapper"><div id="header_bg"></div></span> 
</div>
<div style="height:30px"></div>
</div>
<div class='broider' id='articleContent'>
  <div id="outline"></div>
  <div id="content"></div>
</div>
<div id="toc"></div>
<style>
.broider {
    border-image:  url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFQAAABUCAYAAAAcaxDBAAAAAXNSR0IArs4c6QAAAatJREFUeF7t3EuOwjAABFG4XY7M7WAdI9FquSKZuNjaNJ7nJp8R8Hy0j+N4n57yej3biDvP7zEE/dkHQeG3i6CCwgJwnA0VFBaA42zo5aDpsmh2HP4DVov7bugsWHr+agLwegQVFBaA4/JJaXwLpwVsfm8vaCpIOS5oCZamC5qEyvEMOgZuflmUfAVNQuW4oCVYmi5oEirHe9DyBXabLii844IKCgvAcX1D23v7ccE3v9cX1IbCAnCcDV0O9ObHxNZ7vqGCnswFbSsY5gsqKCwAx9lQQWEBOM6GCgoLwHE2VFBYAI6zoYLCAnCcDRUUFoDjbKigsAAcZ0MFhQXgOBsqKCwAx9lQQWEBOM6GCgoLwHE2VFBYAI6zoZeDzn7+c1zgZh/VyV/vnt1BQYdfDhO0ErChFVee3J+UcubWMwSFt19QQWEBOC6flNrLns2/Ty+oDYUF4Dgbejno+ALpmJjG4QWvHpcvmxJYGl9dAF6foILCAnBcbmh7TIUX+G9xgsI7JqigsAAclxuaLovSOLzg1eMEhXdIUEFhATjOf44ICgvAcTZUUFgAjvsAzQksZB+8F2AAAAAASUVORK5CYII=") 28 /  28px / 0 round;
    border-width:  28px;
    border-style:  solid;
}
</style>

<!-- 
  resize offset path's svg coords 
  https://css-tricks.com/animating-with-clip-path/
  clip-path can use, clip-paths(% relative), or a url to a SVG <clipPath> element
  clip-path CSS property can use the SVG Path attributes for animated transitions.
  The same number of vertices in the path cannot change but only manipulated when animating.
-->
<div id="mframe" style="offset-path: path('M 0 0 L 0 2 L 0 0')"></div>
<style>
  /* Move along path */   
  #mframe {
    position:fixed;
    clip-path: polygon(0% 15%, 15% 15%, 15% 0%, 85% 0%, 85% 15%, 100% 15%, 100% 85%, 85% 85%, 85% 100%, 15% 100%, 15% 85%, 0% 85%);
    animation: move 15s linear infinite;
    width: 40px;
    height: 40px;
    bottom: 160px;
    background: var(--hint-of-light);
    bottom: 160px;
    left: 50%;
    margin-left: -400px;
    z-index:-1;
  }
  @keyframes move {
    0% { offset-distance: 0%; }
    100% { offset-distance: 100%; }
  }
</style>
<script type="text/javascript"> 
// alter the the offsetPath of an HTML element with an ID of 'mframe' 
// replace any 1's with the view width and any 2's with the view height. 
const resizeSvgCoords = async () => {
    let md = document.getElementById("mframe");
    md.style.offsetPath = md.style.offsetPath.replace(/1/g, window.innerWidth).replace(/2/g, window.innerHeight)
}; resizeSvgCoords();
</script>
<script>
function generatePath(bars, w, height) {
    const addPath = (i, h) => `L${Math.round(i*w/bars/20)*20},${h}`; 
    const heights = Array.from({length: bars}, () => height - (rir(2,5) * 40 ));
    const path = heights.map((h, bar) => addPath(bar, h) + addPath(bar + 1, h)).join('');
    return ("M0," + height + path + addPath(bars, height) + "L0," + height + "Z").replace('undefined', '');
}
function updatePath(bars, height) {
  let d = generatePath(6, 800, 200)
  console.log({d})
  document.getElementById("mframe").style.offsetPath = "path('"+d+"')"; 
  document.getElementById("fbg").style.clipPath = "path('"+d+"')"; 
}
updatePath(); setInterval(updatePath,15000) 
</script>

<div style="height:180px"></div>
<style>#fbg{ z-index:-1; min-height:200px; width:800px; position:fixed; bottom: 0px; left: 50%; margin-left: -400px;
  background: linear-gradient(45deg, rgba(255, 183, 183,.1), var(--hint-of-light), rgba(240, 248, 255,.4));}</style>
<div id='fbg'></div>
<div style="padding:10px; text-align:center">Thank you for reading!</div>

<!-- 
  resize svg path 
--
  on scroll temp set offset-distance to percent complete of scroll
  <div id="mframe" style="offset-path: path('M 0 0 L 0 2 L 0 0')"></div>
  #mframe{animation: move 5s linear infinite;}
  @keyframes move {
    0% { offset-distance: 0%; }
    100% { offset-distance: 100%; }
  }
-->
