<svg xmlns="http://www.w3.org/2000/svg" id="svg_bg"></svg>
<div id="gradient_bg"></div>   
<!-- this checkbox holds state of whether modal is visible or not -->
<input checked type="checkbox" id="toggle-sitemap">
<div id="sitemap"> 
  <label for="toggle-sitemap"><span>Hide</span> <span>Show </span>Sitemap</label>
</div>
<div id='template' class='template_article'>
<div id='pageTransitioneer'><p>Don't Look! I'm changing!</p></div>
<div style="height:30px;"></div>

<div id="header">
  <div id="header_nav">
    <h1><a style="cursor: pointer;" href="./">CVMiniGames</a> | <a href="./" id="title"></a></h1>
    <p><a style="cursor: pointer;" href="https://www.cryptovoxels.com/play?coords=N@1447E,1128S">PLAY NOW</a></p>
    <p id="summary"></p>
  </div>
  <span id="header_bg_wrapper"><div id="header_bg"></div></span> 
</div>
<div style="height:30px;"></div>

<div class='broider' id='content'>
  <div id="outline"></div>
  <div id="content"></div>
</div>
<div id="footer">
  <span id="footer_bg_wrapper"><div id="tracer"></div><div id="footer_bg"></div></span> 
</div>
<div style="height:200px"></div>
<p style="padding:10px; text-align:center">Thank you for reading!</p>

<script tag="templateScript" type="text/javascript"> // Animated Background Cubes
// create random # SVG's cubes w random# of sizes,colors,speeds, & positions
// Steps: 0. loop steps 1,2 // 1. reset our svg with rir new cubes. // 2. Animate Cubes top-bottom
rir = (min, max) => Math.floor(Math.random() * (Math.floor(max) - Math.ceil(min) + 1)) + Math.ceil(min);
createCube = () => {
  const x = rir(0,200)+'vh'; const y = rir(0,100)+'vh'; const size = rir(40,80)
  const cube = document.createElementNS("http://www.w3.org/2000/svg", 'rect');
  cube.setAttribute('x', x); cube.setAttribute('y', y);
  cube.setAttribute('height', size); cube.setAttribute('width', size);
  cube.setAttribute('fill', ['red','green','orange', 'blue'][rir(0,3)]);
  cube.classList.add('cube'); return cube;
};
createCubes = () => { return Array(rir(15,25)).fill().map( () =>{c=window.createCube(); window.svg_bg.appendChild(c); return c});  };
animateCubes = () => { [...document.querySelectorAll('.cube')].forEach(cube => { c = cube.style;
    c.setProperty('--startx', `-${rir(0, 10)}vh`); c.setProperty('--endx', `${rir(0, 10)}vh`);
    c.setProperty('--starty', `-${rir(100, 125)}vh`); c.setProperty('--endy', `${rir(100, 125)}vh`);
    cube.style.animation = `cube-animation ${duration/1000}s forwards`;
  }); 
}; 
window.duration = 20000
createAndAnimate = () => { window.svg_bg.innerHTML = ''; window.cubes = createCubes(rir(15, 25)); animateCubes(); };
createAndAnimate(); setInterval(() => { createAndAnimate(20000); }, duration);
</script>

<script tag="templateScript" type="text/javascript">
  // gradient_bg
  dragTarget = document.querySelector("#sitemap"); 
  inDrag = window.inDrag ? inDrag : false;
  function downFN(e) {
      inDrag = true;
      objInitLeft = dragTarget.offsetLeft; objInitTop = dragTarget.offsetTop;
      dragStartX = e.pageX || e.targetTouches[0].clientX; 
      dragStartY = e.pageY || e.targetTouches[0].clientY; 
  }
  function moveFN(e) {
      if (!inDrag) {return;} 
      e.preventDefault();
      dragToX = e.pageX || e.targetTouches[0].clientX; 
      dragToY = e.pageY || e.targetTouches[0].clientY; 
      dragTarget.style.left = (objInitLeft + dragToX-dragStartX) + "px";
      dragTarget.style.top = (objInitTop + dragToY-dragStartY) + "px";
    } 
  (function() {
    // start = mousepos & objInit = topleft of obj
    var dragStartX, dragStartY, objInitLeft, objInitTop = 0;
    dragTarget.addEventListener("mousedown", downFN,{ passive:false });
    document.addEventListener("mousemove", moveFN,{ passive:false });
    document.addEventListener("mouseup", function(e) {inDrag = false}); 
    dragTarget.addEventListener("touchstart", downFN,{ passive:false });
    dragTarget.addEventListener("touchmove", moveFN,{ passive:false });
    dragTarget.addEventListener("touchend", function(e) {inDrag = false;});
  }())
</script>

<script tag="templateScript" type="text/javascript">
function generatePath(bars) { 
  const h = 200; const addPath=(x,y)=>`L${Math.round(x*window.w/bars)},${y}`; 
  const path=Array.from({length:bars},(y,x)=>{y=h-(rir(2,5)*40); return addPath(x,y)+addPath(x+1,y)});
  return ("M0,"+h+path.join('')+addPath(bars, h)+"L0," + h + "Z").replace('undefined', '');
}
function updatePath(bars) {
  const d = generatePath(6);
  document.getElementById("tracer").style.offsetPath = "path('"+d+"')"; 
  document.getElementById("footer_bg").style.animation = "none"; //Glitchy animation fix
  // set css var --path2 to --path1's computed value and update --path1 with new path(d)
  const p = getComputedStyle(document.documentElement).getPropertyValue('--path1');
  document.getElementById("footer_bg").style.animation = "clip-path-polygon 15s linear";
  document.documentElement.style.setProperty('--path2', p || "path('"+d+"')");
  document.documentElement.style.setProperty('--path1', "path('"+d+"')");
}

window.w=Math.min(window.innerWidth, 800); 
updatePath(); setInterval(updatePath,15000);
document.addEventListener('scroll', function() {
  let scrollPercent = (document.documentElement.scrollTop + document.body.scrollTop) / (document.documentElement.scrollHeight - document.documentElement.clientHeight) * 100;
  scrollPercent = (scrollPercent / 100) * 45 + 10;
  document.documentElement.style.setProperty('--change1', scrollPercent+'%' );
  document.documentElement.style.setProperty('--change2', scrollPercent+'%' );
  clearInterval(window.scrollTimer);
  window.scrollTimer = setInterval(() => {
    document.documentElement.style.setProperty('--change1', "0%");
    document.documentElement.style.setProperty('--change2', "100%");
  }, 1500); 
});
</script>