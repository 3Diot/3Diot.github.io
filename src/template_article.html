<svg xmlns="http://www.w3.org/2000/svg" id="svg_bg"></svg> 
<!-- this checkbox holds state of whether modal is visible or not -->
<input checked type="checkbox" id="toggle-sitemap">
<div id="sitemap"> 
  <label for="toggle-sitemap"><span>Hide</span> <span>Show </span>Sitemap</label>
</div>
<div id='template' class='template_article'>
<div id='pageTransitioneer'><p>Don't Look! I'm changing!</p></div>

<div id="gradient_bg"> 
</div>  

<div id="header">
  <div id="header_nav">
    <h1><a style="cursor: pointer;" href="./">CVMiniGames</a> | <a href="./" id="title"></a></h1>
    <p><a style="cursor: pointer;" href="https://www.cryptovoxels.com/play?coords=N@1447E,1128S">PLAY NOW</a></p>
    <p id="summary"></p>
  </div>
  <span id="header_bg_wrapper"><div id="header_bg"></div></span> 
</div>

<div class='broider' id='content'>
  <div id="outline"></div>
  <div id="content"></div>
</div>
<div id="footer">
  <span id="footer_bg_wrapper"><div id="tracer"></div><div id="footer_bg"></div></span> 
</div> 
<p id="thanks">Thank's for visiting!</p>

<script tag="templateScript" type="text/javascript"> // Animated Background Cubes
// create random # SVG's cubes w random# of sizes,colors,speeds, & positions
// Steps: 0. loop steps 1,2 // 1. reset our svg with rir new cubes. // 2. Animate Cubes top-bottom
rir = (min, max) => Math.floor(Math.random() * (Math.floor(max) - Math.ceil(min) + 1)) + Math.ceil(min);
createCube = () => {
  const x = rir(0,200)+'vh'; const y = rir(0,100)+'vh'; const size = rir(40,80)
  const cube = document.createElementNS("http://www.w3.org/2000/svg", 'rect');
  cube.setAttribute('x', x); cube.setAttribute('y', y);
  cube.setAttribute('height', size); cube.setAttribute('width', size);
  cube.setAttribute('fill', ['red','green','orange', 'blue'][rir(0,3)]);
  cube.classList.add('cube'); return cube;
};
createCubes = () => { return Array(rir(15,25)).fill().map( () =>{c=window.createCube(); window.svg_bg.appendChild(c); return c});  };
animateCubes = () => { [...document.querySelectorAll('.cube')].forEach(cube => { c = cube.style;
    c.setProperty('--startx', `-${rir(0, 10)}vh`); c.setProperty('--endx', `${rir(0, 10)}vh`);
    c.setProperty('--starty', `-${rir(100, 125)}vh`); c.setProperty('--endy', `${rir(100, 125)}vh`);
    cube.style.animation = `cube-animation ${duration/1000}s forwards`;
  }); 
}; 
window.duration = 20000
createAndAnimate = () => { window.svg_bg.innerHTML = ''; window.cubes = createCubes(rir(15, 25)); animateCubes(); };
createAndAnimate(); setInterval(() => { createAndAnimate(20000); }, duration);
</script>

<script tag="templateScript" type="text/javascript">
  dragTarget = document.querySelector("#sitemap"); // alternately toggle-sitemap if sitemap-content scroll behaviors is not good.
  inDrag = window.inDrag ? inDrag : false;
  function downFN(e) {
      inDrag = true;
      objInitLeft = dragTarget.offsetLeft; objInitTop = dragTarget.offsetTop;
      dragStartX = e.pageX || e.targetTouches[0].clientX; 
      dragStartY = e.pageY || e.targetTouches[0].clientY; 
  }
  function moveFN(e) {
      if (!inDrag) {return;} 
      e.preventDefault();
      document.getElementById('drag').style.display='none';
      dragToX = e.pageX || e.targetTouches[0].clientX; 
      dragToY = e.pageY || e.targetTouches[0].clientY; 
      dragTarget.style.left = (objInitLeft + dragToX-dragStartX) + "px";
      dragTarget.style.top = (objInitTop + dragToY-dragStartY) + "px";
    } 
  (function() {
    // start = mousepos & objInit = topleft of obj
    var dragStartX, dragStartY, objInitLeft, objInitTop = 0;
    dragTarget.addEventListener("mousedown", downFN,{ passive:false });
    document.addEventListener("mousemove", moveFN,{ passive:false });
    document.addEventListener("mouseup", function(e) {inDrag = false}); 
    dragTarget.addEventListener("touchstart", downFN,{ passive:false });
    dragTarget.addEventListener("touchmove", moveFN,{ passive:false });
    dragTarget.addEventListener("touchend", function(e) {inDrag = false;});
  }())
</script>

<script tag="templateScript" type="text/javascript">
function generatePath(bars) { 
  const h = 200; const addPath=(x,y)=>`L${Math.round(x*window.w/bars)},${y}`; 
  const path=Array.from({length:bars},(y,x)=>{y=h-(rir(2,5)*40); return addPath(x,y)+addPath(x+1,y)});
  return ("M0,"+h+path.join('')+addPath(bars, h)+"L0," + h + "Z").replace('undefined', '');
}
function updatePath(bars) {
  const newPath = "path('"+generatePath(6)+"')"
  const footer = document.getElementById("footer_bg").style 
  // set css var --path2 to --path1's computed value and update --path1 with new path(d)
  const pastPath = getComputedStyle(document.documentElement).getPropertyValue('--path1');
  footer.clipPath = pastPath;
  // Using css vars helps ensure auto-prefixing is done correctly 
  document.documentElement.style.setProperty('--path1', newPath);
  document.documentElement.style.setProperty('--path2', pastPath || newPath);
  //Fix for Glitchy animation Otherwise flashes end of animation before starting again.
  footer.animation = "none"; 
  setTimeout(()=>{ 
    document.getElementById("tracer").style.offsetPath = newPath;
    footer.animation = "clip-path-polygon 1s forwards"; 
  },10)
}
window.w=Math.min(window.innerWidth, 800); 
updatePath(); setInterval(updatePath,8000);

document.addEventListener('scroll', function() {
  let scrollPercent = (document.documentElement.scrollTop + document.body.scrollTop) / (document.documentElement.scrollHeight - document.documentElement.clientHeight) * 100;
  scrollPercent = (scrollPercent / 100) * 45 + 10;
  document.documentElement.style.setProperty('--change1', scrollPercent+'%' );
  document.documentElement.style.setProperty('--change2', scrollPercent+'%' );
  clearInterval(window.scrollTimer);
  window.scrollTimer = setInterval(() => {
    document.documentElement.style.setProperty('--change1', "0%");
    document.documentElement.style.setProperty('--change2', "100%");
  }, 1500); 
});
</script>

<script tag="templateScript" type="text/javascript">
// 6 
// Hit em w/ the ol razzle dazzle; and give em the wiggles~! >:D
// IntersectionObserver for animations and Highlighting active TOC Anchor link
window.activeHeader = null
const observer = new IntersectionObserver((entries) => { 
    entries.forEach((entry) => {let e=entry.target
        let txt = "0.5s ease-in-out 0s 2 normal none running wiggle";
        let pos = e.getBoundingClientRect().top
        let el = (e.parentNode.nodeName == "SUMMARY" && e.parentNode.style || e.style ) 
        if (!entry.isIntersecting){ el.animation == txt && (el.animation = ''); return; }
        el.animation = txt 
        if(pos<300 || pos>300){ /* ' Scrolling', pos>100?'Down: ':'Up */  
            window.activeHeader && (window.activeHeader.style.textDecoration='none')
            let tocLink = document.getElementById('anchor_link_'+e.id)
            tocLink && ( tocLink.style.animation = txt, tocLink.style.textDecoration='line-through' ) 
            window.activeHeader = tocLink
        }
    });
});

loadObserver = (t) =>{ document.querySelectorAll('h2,h3,h4,h5,h6').forEach((el) => observer.observe(el) ) };  
window.addEventListener('templateLoaded', async () =>{ 
  if(window.isSmall){ document.getElementById('toggle-sitemap').checked=false; }
  setTimeout( ()=>loadObserver(),2000) 
} );
!window.inDev && loadObserver();

</script>
<script tag="templateScript" type="text/javascript">
// Wite map styling. The if needs js, the else isn't really needed. Could be done in css too.
setTimeout( ()=>{ 
  var sm = document.getElementById("toggle-sitemap");
  if(window.screen.width <= 800){ sm.checked=false;}
  else{
    sm.checked=true;
    var sitemap = document.getElementById("sitemap");
    var size = sitemap.offsetWidth;
    var space = document.querySelector(".broider").getBoundingClientRect().left;
    if( space > size ){ sitemap.style.left=space-size+"px";}
  }
},1000) 
</script>